def playbookChoices = []
def targetChoices = ['all']
node {
    checkout scm
    def playbooks = sh(returnStdout: true, script: "find ansible/playbooks/ | grep .yml 2>/dev/null || true")
    playbooks.split().each { playbook ->
        playbookChoices << playbook.replace('ansible/playbooks/', '')
    }
    playbookChoices.add(0, 'Update Inventory and Playbooks List')
    
    // Use Ansible inventory JSON output to get ALL hosts and groups
    try {
        withCredentials([file(credentialsId: 'ansible-inventory', variable: 'INVENTORY_CONTENT')]) {
            writeFile file: 'temp_hosts.ini', text: readFile(env.INVENTORY_CONTENT)
            
            // Get all hosts - comprehensive method
            def hostsOutput = sh(returnStdout: true, script: '''
                ansible-inventory -i temp_hosts.ini --list-hosts all 2>/dev/null | \\
                grep -v '^\\s*hosts (' | grep -v '^\\s*\\[' | \\
                grep -v '^\\s*$' | sed 's/^\\s*//' || true
            ''').trim()
            
            if (hostsOutput) {
                hostsOutput.split('\n').each { line ->
                    line = line.trim()
                    if (line && line != 'all') {
                        targetChoices << line
                    }
                }
            }
            
            // Get all groups using JSON output - most comprehensive
            def jsonOutput = sh(returnStdout: true, script: '''
                ansible-inventory -i temp_hosts.ini --list 2>/dev/null || echo '{}'
            ''').trim()
            
            if (jsonOutput && jsonOutput != '{}') {
                try {
                    def inventory = readJSON text: jsonOutput
                    inventory.keySet().each { key ->
                        if (key != 'all' && key != '_meta' && key != 'ungrouped') {
                            targetChoices << key
                        }
                    }
                } catch (Exception jsonError) {
                    echo "JSON parsing failed, using fallback method: ${jsonError.message}"
                    
                    // Fallback: parse groups from --graph output
                    def graphOutput = sh(returnStdout: true, script: '''
                        ansible-inventory -i temp_hosts.ini --graph 2>/dev/null | \\
                        grep '@' | sed 's/^[^@]*@\\([^:]*\\):.*/\\1/' || true
                    ''').trim()
                    
                    if (graphOutput) {
                        graphOutput.split('\n').each { line ->
                            line = line.trim()
                            if (line && line != 'all' && line != 'ungrouped') {
                                targetChoices << line
                            }
                        }
                    }
                }
            }
            
            sh "rm -f temp_hosts.ini"
        }
    } catch (Exception e) {
        echo "Could not read inventory for target choices: ${e.message}"
        // Fallback: add some common targets
        targetChoices.addAll(['proxmox-cluster', 'custom-vms'])
    }
    targetChoices = targetChoices.unique().sort()
}

pipeline {
    agent {
        label 'ansible'
    }

    parameters {
        choice(
            name: 'PLAYBOOK',
            choices: playbookChoices,
            description: 'Select playbook to run or Update to refresh the inventory and playbooks list'
        )
        choice(
            name: 'TARGET',
            choices: targetChoices,
            description: 'Select target host or group'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Run in check mode (dry run)'
        )
        string(
            name: 'TAGS',
            defaultValue: '',
            description: 'Only run tasks with these tags (optional)'
        )
        text(
            name: 'EXTRA_VARS',
            defaultValue: '''var1=value1
var2=value2
var3=value3''',
            description: 'Extra variables to pass to the playbook (one per line, format: key=value)'
        )
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        ANSIBLE_FORCE_COLOR = '1'
        ANSIBLE_VAULT_PASSWORD_FILE = '${WORKSPACE}/ansible/.vault_pass'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Setup') {
            steps {
                withCredentials([
                    file(credentialsId: 'ansible-inventory', variable: 'INVENTORY_CONTENT'),
                    string(credentialsId: 'ansible-vault-password', variable: 'VAULT_PASSWORD')
                ]) {
                    writeFile file: 'ansible/hosts.ini', text: readFile(env.INVENTORY_CONTENT)
                    writeFile file: 'ansible/.vault_pass', text: env.VAULT_PASSWORD
                }
            }
        }

        stage('Update Inventory and Playbooks List') {
            when {
                expression { params.PLAYBOOK == 'Update Inventory and Playbooks List' }
            }
            steps {
                echo '✅ Inventory and Playbook list updated successfully!'
                script {
                    // Show current inventory for debugging
                    echo "=== INVENTORY GRAPH ==="
                    sh "ansible-inventory -i ansible/hosts.ini --graph || true"
                    echo "=== ALL HOSTS ==="
                    sh "ansible-inventory -i ansible/hosts.ini --list-hosts all || true"
                    echo "=== ALL GROUPS (JSON) ==="
                    sh "ansible-inventory -i ansible/hosts.ini --list | jq 'keys[]' 2>/dev/null || echo 'jq not available, showing raw JSON:'"
                    sh "ansible-inventory -i ansible/hosts.ini --list || true"
                }
            }
        }

        stage('Validate Playbook') {
            when {
                expression { params.PLAYBOOK != 'Update Inventory and Playbooks List' }
            }
            steps {
                script {
                    if (!params.PLAYBOOK) {
                        error "Please specify a playbook to run"
                    }
                    if (!fileExists("ansible/playbooks/${params.PLAYBOOK}")) {
                        error "Playbook ${params.PLAYBOOK} does not exist in ansible/playbooks/"
                    }
                }
                sh """
                    cd ansible
                    ansible-playbook --syntax-check playbooks/${params.PLAYBOOK} -i hosts.ini
                """
            }
        }

        stage('Run Ansible Playbook') {
            when {
                expression { params.PLAYBOOK != 'Update Inventory and Playbooks List' }
            }   
            steps {
                withCredentials([
                    string(credentialsId: 'ansible-ssh-key-pub', variable: 'ANSIBLE_SSH_KEY_PUB')
                ]) {
                    withEnv(['ANSIBLE_SSH_KEY_PUB=' + env.ANSIBLE_SSH_KEY_PUB]) {
                        script {
                            def extraVars = [
                                ansible_python_interpreter: '/usr/bin/python3',
                                target: params.TARGET
                            ]
                            
                            if (params.EXTRA_VARS?.trim()) {
                                params.EXTRA_VARS.split('\n').each { line ->
                                    if (line.contains('=')) {
                                        def parts = line.split('=', 2)
                                        extraVars[parts[0].trim()] = parts[1].trim()
                                    }
                                }
                            }
                            
                            ansiblePlaybook(
                                playbook: "ansible/playbooks/${params.PLAYBOOK}",
                                inventory: "ansible/hosts.ini",
                                credentialsId: 'ansible-ssh-key',
                                disableHostKeyChecking: true,
                                colorized: true,
                                extraVars: extraVars,
                                tags: params.TAGS ?: '',
                                checkMode: params.DRY_RUN
                            )
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
            script {
                currentBuild.description = "Playbook: ${params.PLAYBOOK}, Target: ${params.TARGET}"
            }
        }
        success {
            echo '✅ Playbook executed successfully!'
        }
        failure {
            echo '❌ Playbook execution failed!'
        }
    }
} 